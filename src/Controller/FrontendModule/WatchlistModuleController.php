<?php

/*
 * Copyright (c) 2022 Heimrich & Hannot GmbH
 *
 * @license LGPL-3.0-or-later
 */

namespace HeimrichHannot\WatchlistBundle\Controller\FrontendModule;

use Contao\CoreBundle\DependencyInjection\Attribute\AsFrontendModule;
use Contao\CoreBundle\Controller\FrontendModule\AbstractFrontendModuleController;
use Contao\CoreBundle\Exception\ResponseException;
use Contao\CoreBundle\Filesystem\FileDownloadHelper;
use Contao\CoreBundle\Filesystem\FilesystemItem;
use Contao\CoreBundle\Filesystem\FilesystemItemIterator;
use Contao\CoreBundle\Filesystem\VirtualFilesystemInterface;
use Contao\CoreBundle\Twig\FragmentTemplate;
use Contao\Environment;
use Contao\ModuleModel;
use HeimrichHannot\EncoreContracts\PageAssetsTrait;
use HeimrichHannot\UtilsBundle\Util\Utils;
use HeimrichHannot\WatchlistBundle\Controller\AjaxController;
use HeimrichHannot\WatchlistBundle\Item\WatchlistItem;
use HeimrichHannot\WatchlistBundle\Model\WatchlistModel;
use HeimrichHannot\WatchlistBundle\Util\WatchlistUtil;
use HeimrichHannot\WatchlistBundle\Watchlist\WatchlistContentFactory;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\StreamedResponse;
use Symfony\Contracts\Translation\TranslatorInterface;

#[AsFrontendModule(WatchlistModuleController::TYPE, category: 'miscellaneous')]
class WatchlistModuleController extends AbstractFrontendModuleController
{
    use PageAssetsTrait;

    public const TYPE = 'watchlist';

    public function __construct(
        protected WatchlistUtil              $watchlistUtil,
        private readonly Utils               $utils,
        private readonly TranslatorInterface $translator,
        private readonly WatchlistContentFactory $watchlistContentFactory,
        private readonly VirtualFilesystemInterface $filesStorage,
        private readonly FileDownloadHelper $fileDownloadHelper,
    ) {}

    public function __invoke(Request $request, ModuleModel $model, string $section, ?array $classes = null): Response
    {
        $this->handleDownload($request);
        return parent::__invoke($request, $model, $section, $classes); // TODO: Change the autogenerated stub
    }


    public function getResponse(FragmentTemplate $template, ModuleModel $module, Request $request): Response
    {
        if ($this->isBackendScope($request)) {
            return new Response('');
        }

        $this->addPageEntrypoint('contao-watchlist-bundle', [
            'TL_JAVASCRIPT' => [
                'contao-watchlist-bundle' => 'bundles/heimrichhannotwatchlist/assets/contao-watchlist-bundle.js|static',
            ],
        ]);

        $objPage = $this->getPageModel();

        // watchlist
        $config = $this->watchlistUtil->getCurrentWatchlistConfig();
        $watchlist = $this->watchlistUtil->getCurrentWatchlist();

        if (!$config) {
            return $template->getResponse();
        }

        $currentUrl = parse_url((string)Environment::get('uri'), \PHP_URL_PATH);

        $template->set(
            'watchlistUpdateUrl',
            $this->utils->url()->addQueryStringParameterToUrl(
                parameter: 'wl_root_page=' . $objPage->rootId . '&wl_url=' . urlencode($currentUrl),
                url: Environment::get('url') . AjaxController::WATCHLIST_CONTENT_URI
            )
        );

        if (null === $watchlist) {
            $template->set('title', $this->translator->trans('MSC.watchlistBundle.watchlist', [], 'contao_default'));
        } else {
            $template->set('title', $watchlist->title);
        }

        $template->set('watchlistContent', $this->watchlistContentFactory->build(
            $watchlist ?: $config,
            pageModel: $objPage,
        ));

        return $template->getResponse();
    }

    protected function getFilesystemItems(WatchlistModel $watchlist): FilesystemItemIterator
    {
        $content =  $this->watchlistContentFactory->build(
            $watchlist,
            pageModel: $this->getPageModel(),
        );

        $fileItems = array_map(fn(WatchlistItem $item) => $item->getFile(), $content->items);
        return new FilesystemItemIterator($fileItems);
    }

    protected function handleDownload(Request $request): void
    {
        $watchlist = $this->watchlistUtil->getCurrentWatchlist();
        if (!$watchlist) {
            throw new \RuntimeException();
        }

        $response = $this->fileDownloadHelper->handle(
            $request,
            $this->filesStorage,
            function (FilesystemItem $item, array $context) use ($watchlist, $request): Response|null {
                // Do not handle downloads from other DownloadController elements on the same
                // page (see #5568)
                if ($watchlist->id !== ($context['watchlist'] ?? null)) {
                    return new Response('', Response::HTTP_NO_CONTENT);
                }

                if (!$this->getFilesystemItems($watchlist)->any(static fn (FilesystemItem $listItem) => $listItem->getPath() === $item->getPath())) {
                    return new Response('The resource can not be accessed anymore.', Response::HTTP_GONE);
                }

                return null;
            },
        );

        if ($response instanceof StreamedResponse || $response instanceof BinaryFileResponse) {
            throw new ResponseException($response);
        }
    }
}
